import numpy as np
import pandas as pd
from ..utils.validation import is_index_mono_inc
from ..utils.decorators import deprecated

@deprecated(new_func_name='ExAnteVolatilityEstimator.FromSeries')
def compute_ex_ante_volatility(daily_returns, com=60, annualization_factor=261):
    """
    Compute the ex ante annualized volatility for a series of daily returns.
    
    Parameters
    ----------
    daily_returns : pd.Series
        A series of daily returns.
    com : float, default=60
        The center of mass for the exponential moving average.
    annualization_factor : int, default=261
        
    Returns
    -------
    ex_ante_volatility : pd.Series
        The ex ante annualized volatility of the daily returns.
    """
    if isinstance(daily_returns, np.ndarray):
        daily_returns = pd.Series(daily_returns)
    if isinstance(daily_returns, list):
        daily_returns = pd.Series(daily_returns)
    
    # Calculate the exponentially weighted average return
    ewma_returns = daily_returns.ewm(com=com).mean()
    
    # Calculate the squared deviations from the exponentially weighted average return
    squared_deviations = (daily_returns - ewma_returns) ** 2
    
    # Calculate the exponentially weighted variance
    ewma_variance = squared_deviations.ewm(com=com).mean()
    
    # Annualize the variance
    annual_variance = ewma_variance * annualization_factor
    
    # Calculate the annualized volatility (standard deviation)
    ex_ante_volatility = np.sqrt(annual_variance)
    
    return ex_ante_volatility


class ExAnteVolatilityEstimator:
    def __init__(self, values, com, annualization_factor):
        self.values = values
        self.com = com
        self.annualization_factor = annualization_factor
    
    @classmethod
    def FromSeries(cls, returns, com=60, annualization_factor=261):
        """
        Generate an ex ante volatility signal from a series of daily returns
        
        Parameters
        ----------
        daily_returns : pd.Series
            A series of daily returns
        com : float, default=60
            The center of mass for the exponential moving average
        annualization_factor : int, default=261
            The annualization factor
        threshold : float, default=0.1
            The threshold for the signal
        
        Returns
        -------
        signal_object : ExAnteVolatilitySignal
            An ExAnteVolatilitySignal object


        Examples
        --------
            # the ewma volatility is comparable to the rolling volatility
            returns = pd.Series(np.random.normal(0, 1, 1000))
            returns.rolling(60).std().plot(label='Rolling')
            ewma_returns = returns.ewm(com=60).mean()
            variance = (returns - ewma_returns) ** 2
            ewma_variance = variance.ewm(com=60).mean()
            std = np.sqrt(ewma_variance)
            std.plot(label='EWMA')
            plt.legend()
        """
        if isinstance(returns, np.ndarray):
            returns = pd.Series(returns)
        if isinstance(returns, list):
            returns = pd.Series(returns)
        
        # Calculate the exponentially weighted average return
        ewma_returns = returns.ewm(com=com).mean()
        
        # Calculate the squared deviations from the exponentially weighted average return
        squared_deviations = (returns - ewma_returns) ** 2
        
        # Calculate the exponentially weighted variance
        ewma_variance = squared_deviations.ewm(com=com).mean()
        
        # Annualize the variance
        annual_variance = ewma_variance * annualization_factor
        
        # Calculate the annualized volatility (standard deviation)
        ex_ante_volatility = np.sqrt(annual_variance)
        
        return cls(ex_ante_volatility, com, annualization_factor)
    
    def to_list(self):
        return self.values.tolist()


class TimeSeriesMomentumSignal:
    def __init__(self, signals, k = 5):
        self.signals = signals
    
    @classmethod
    def FromSeries(cls, returns, k = 5):
        """
        Generate a time series momentum signal from a series of returns

        Time series momentum signal is generated by looking at the past k days of returns and generate a signal based on the sign of the sum of the returns
        
        Parameters
        ----------
        returns : pd.Series
            A series of returns
        k : int, default=5
            The number of days to look back

        Returns
        -------
        signal_object : TimeSeriesMomentumSignal
            A TimeSeriesMomentumSignal object
        """
        if not isinstance(returns, pd.Series):
            raise ValueError("returns must be a pandas Series")
        if not is_index_mono_inc(returns):
            raise ValueError("returns must have a monotonically increasing index")
        
        rolling_sum = returns.rolling(window = k).sum()
        signals = np.sign(rolling_sum)
        return cls(signals, k)
    
    def to_list(self):
        return self.signals.tolist()
    

@deprecated(new_func_name='TimeSeriesMomentumSignal.FromSeries')
def generate_ts_momentum_signal(returns, k = 5):
    """generate a time series momentum signal
    
    Look at the past k days of returns and generate a signal based on the sign of the sum of the returns
    
    Notes
    -----
    To avoid look-ahead bias, the look back period is from t-1 to t-k
    
    Parameters
    ----------
    returns : pd.Series
        A series of returns, assuming that the returns are already in log form
    k : int, default=5
        The number of days to look back.
        
    Returns
    -------
    signals : pd.Series
        A series of signals, where 1 indicates a long position, -1 indicates a short position, and 0 indicates no position
    """
    shifted_returns = returns.shift(1)
    rolling_sum = shifted_returns.rolling(window = k).sum()
    signals = np.sign(rolling_sum)
    return signals
    